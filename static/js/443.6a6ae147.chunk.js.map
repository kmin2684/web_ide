{"version":3,"file":"static/js/443.6a6ae147.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/monaco-jsx-highlighter/node_modules/style-inject/dist/style-inject.es.js","../node_modules/monaco-jsx-highlighter/src/utils/babel.js","../node_modules/monaco-jsx-highlighter/src/utils/monaco.js","../node_modules/monaco-jsx-highlighter/src/core/DecoratorMapper.js","../node_modules/monaco-jsx-highlighter/src/core/Commenter.js","../node_modules/monaco-jsx-highlighter/src/core/MonacoJSXHighlighter.js"],"sourcesContent":["function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","// gets JSX expressions within a Babel's AST\nexport const collectJSXExpressions = (ast, traverse, traverseOptions = {}) => {\n   const jsxExpressions = [];\n   \n   const enter = (path) => {\n      if (path.type.toUpperCase().includes(\"JSX\")) {\n         jsxExpressions.push(path);\n      }\n   }\n   \n   traverse(ast, {...traverseOptions, enter});\n   \n   return jsxExpressions;\n}\n\nexport const isJSXIdentifier = (path) => {\n   return (path && (\n         path.key === 'object' ||\n         path.key === 'property' ||\n         path.key === 'name' ||\n         path.key === 'namespace'\n      )\n   );\n}\n\nexport const isParentJSXAttribute = (path) => {\n   return (\n      path &&\n      path.parentPath &&\n      path.parentPath.isJSXAttribute()\n   );\n};\n\nexport const getLoc = (path) => {\n   return (path && path.node && path.node.loc);\n};\n\nexport const cloneLoc = (path) => {\n   const loc = getLoc(path);\n   \n   if (!loc) {\n      return null;\n   }\n   \n   return {\n      start: {...loc.start},\n      end: {...loc.end}\n   };\n   \n};\n\n// prevents spilling highlighting on objects props\nexport const getCuratedLoc = (path) => {\n   const loc = cloneLoc(path);\n   \n   if (!loc) {\n      return [null, null, null, null];\n   }\n   \n   if (path.key === 'object' && path.container) {\n      loc.end = {...path.container.property.loc.start};\n   }\n   \n   return loc;\n   \n};\n\nexport const extractJSXOpeningElement = (path) => {\n   const loc = getLoc(path);\n   \n   if (!loc) {\n      return [null, null, null, null];\n   }\n   \n   const openingElement = path.node.openingElement;\n   \n   if (!openingElement) {\n      return [null, null, null, null];\n   }\n   \n   const elementName = openingElement.name.name;\n   \n   const startLoc = {\n      start: {...openingElement.loc.start},\n      end: {...openingElement.name.loc.start}\n   };\n   \n   const endLoc = {\n      start: {...openingElement.loc.end},\n      end: {...openingElement.loc.end}\n   };\n   endLoc.start.column--;\n   \n   if (openingElement.selfClosing) {\n      endLoc.start.column--;\n   }\n   \n   return [openingElement, elementName, startLoc, endLoc];\n};\n\nexport const extractJSXClosingElement = (path) => {\n   const loc = getLoc(path);\n   \n   if (!loc) {\n      return [null, null, null, null];\n   }\n   \n   const closingElement = path.node.closingElement;\n   \n   if (!closingElement) {\n      return [null, null, null, null];\n   }\n   \n   const elementName = closingElement.name && closingElement.name.name;\n   \n   const startLoc = {\n      start: {...closingElement.loc.start},\n      end: {...closingElement.name.loc.start}\n   };\n   \n   const endLoc = {\n      start: {...closingElement.loc.end},\n      end: {...closingElement.loc.end}\n   };\n   endLoc.start.column--;\n   \n   return [closingElement, elementName, startLoc, endLoc];\n};\n\nexport const extractJSXExpressionEdges = (path) => {\n   const loc = getLoc(path);\n   \n   if (!loc) {\n      return [null, null, null, null];\n   }\n   \n   let innerNode = null;\n   let innerLocKey = path.isJSXSpreadChild() ? 'expression'\n      : path.isJSXSpreadAttribute() ? 'argument'\n         : null;\n   \n   let innerLoc = null;\n   \n   if (innerLocKey) {\n      innerNode = path.node[innerLocKey];\n      \n      innerLoc = {\n         start: {...innerNode.loc.start},\n         end: {...innerNode.loc.end}\n      };\n      \n      if (innerNode.extra && innerNode.extra.parenthesized) {\n         innerLoc.start.column--;\n         innerLoc.end.column++;\n      }\n   } else {\n      innerLoc = {start: {...loc.start}, end: {...loc.end}};\n      innerLoc.start.column++;\n      innerLoc.end.column--;\n   }\n   \n   const startEdgeLoc = {start: {...loc.start}, end: {...innerLoc.start}};\n   \n   const endEdgeLoc = {start: {...innerLoc.end}, end: {...loc.end}};\n   return [innerNode, innerLocKey, startEdgeLoc, endEdgeLoc];\n};\n","export const COMMENT_ACTION_ID = \"editor.action.commentLine\";\n\n// adapts location objects (e.g. Babel uses internally Acorn) to Monaco Ranges\nexport const configureLoc2Range = (\n   monaco, parserType = 'babel'\n) => {\n   switch (parserType) {\n      case 'babel':\n      default:\n         return (\n            loc,\n            startLineOffset = 0,\n            startColumnOffset = 0,\n            endLineOffset = 0,\n            endColumnOffset = 0,\n         ) => {\n            if (!loc || !loc.start) {\n               return new monaco.Range(\n                  1,\n                  1,\n                  1,\n                  1\n               );\n            }\n            return new monaco.Range(\n               startLineOffset + loc.start.line,\n               startColumnOffset + loc.start.column + 1,\n               endLineOffset + loc.end ?\n                  loc.end.line\n                  : loc.start.line,\n               endColumnOffset + loc.end ?\n                  loc.end.column + 1\n                  : loc.start.column + 1,\n            );\n         };\n   }\n};\n\nexport const configureRange2Loc = (\n   parserType = 'babel'\n) => {\n   switch (parserType) {\n      case 'babel':\n      default:\n         return (\n            rangeOrPosition,\n            startLineOffset = 0,\n            startColumnOffset = 0,\n            endLineOffset = 0,\n            endColumnOffset = 0,\n         ) => {\n            const loc = {\n               start: {line: 0, column: 0},\n               end: {line: 0, column: 0}\n            };\n            \n            if (!rangeOrPosition) {\n               return loc;\n            }\n            \n            // position\n            if (rangeOrPosition.lineNumber) {\n               loc.start.line =\n                  startLineOffset + rangeOrPosition.lineNumber;\n               loc.start.column =\n                  startColumnOffset + rangeOrPosition.column - 1;\n               loc.end.line = endLineOffset + rangeOrPosition.lineNumber;\n               loc.end.column = endColumnOffset + rangeOrPosition.column - 1;\n            } else {\n               loc.start.line =\n                  startLineOffset + rangeOrPosition.startLineNumber;\n               loc.start.column =\n                  startColumnOffset + rangeOrPosition.startColumn - 1;\n               loc.end.line = endLineOffset + rangeOrPosition.endLineNumber;\n               loc.end.column = endColumnOffset + rangeOrPosition.endColumn - 1;\n            }\n            \n            return loc;\n         };\n   }\n};\n\nexport class MonacoEditorManager {\n   constructor(monacoEditor, monaco, loc2Range) {\n      this.monacoEditor = monacoEditor;\n      this.monaco = monaco;\n      this.loc2Range = loc2Range || configureRange2Loc(monaco);\n      \n      // default editor comment action\n      this.runEditorCommentLineAction = () => {\n         return this.monacoEditor\n            .getAction(COMMENT_ACTION_ID)\n            .run();\n      };\n      \n      // preserves indentation when commenting code\n      this.getLineIndentationColumn = (lineNumber) => {\n         return this.monacoEditor\n            .getModel()\n            .getLineFirstNonWhitespaceColumn(\n               lineNumber\n            );\n      };\n      \n      this.getCommentableStartingRange = (range) => {\n         const startColumn = this.getLineIndentationColumn(\n            range.startLineNumber\n         );\n         \n         // creates an anchor to check for comments\n         const commentableRange = new this.monaco.Range(\n            range.startLineNumber,\n            startColumn,\n            range.startLineNumber,\n            startColumn,\n         );\n         \n         return commentableRange;\n      };\n      \n      this.getCommentContainingStartingRange = (range) => {\n         // preserves indentation when commenting code\n         let startColumn = this.getLineIndentationColumn(\n            range.startLineNumber\n         );\n         \n         startColumn = startColumn ? startColumn - 1 : 0;\n         const containingRange = new this.monaco.Range(\n            range.startLineNumber,\n            startColumn,\n            range.startLineNumber,\n            startColumn,\n         );\n         \n         return containingRange;\n      };\n      \n      this.getSelectionFirstLineText = () => {\n         const model = this.monacoEditor.getModel();\n         const {startLineNumber} = this.monacoEditor.getSelection();\n         \n         const jsCommentRange = new this.monaco.Range(\n            startLineNumber,\n            this.getLineIndentationColumn(\n               startLineNumber\n            ),\n            startLineNumber,\n            model.getLineMaxColumn(startLineNumber),\n         );\n         return model.getValueInRange(jsCommentRange);\n      };\n   }\n}\n","import {\n   extractJSXOpeningElement,\n   extractJSXClosingElement,\n   getLoc,\n   getCuratedLoc,\n   isJSXIdentifier,\n   isParentJSXAttribute,\n   extractJSXExpressionEdges\n} from \"../utils/babel\";\n\nexport const prepareOptions =(\n   path,\n   jsxTypeOptions = {},\n   highlighterOptions = {}\n) =>{\n   return highlighterOptions.iShowHover ?\n      {...jsxTypeOptions, ...{hoverMessage: `(${path.type})`}}\n      : jsxTypeOptions;\n};\n\nexport const HIGHLIGHT_TYPE = {\n   ELEMENT: 'ELEMENT', // jsx elements\n   ALL: 'ALL', // the whole node's location, e.g. identifier names\n   IDENTIFIER: 'IDENTIFIER', // JSX identifiers\n   EDGE: 'EDGE', // only the  starting and ending characters in node's\n   // location e.g. spread child or attribute, container expressions\n   STYLE: 'STYLE', // for styling only, not used by node locations\n};\n\n\nexport const HIGHLIGHT_MODE = {\n   /**\n    *  ALL functions follow this signature:\n    *  @param {Babel Path} - the path to process.\n    *  @param {Object} jsxTypeOptions - the Monaco Decorator options to be used.\n    *  @param {Object} highlighterOptions - this library configuration for\n    *  highlighting.\n    *  @returns {Array} a collection JSX entries, each entry is an array too:\n    *  0: location object matching Babel's Location structure.\n    *  1: JSXTypes' Monaco options to create a highlighting  decorator.\n    *  Note: Purposely array entries to prevent using them directly with\n    Monaco without properly adapting Babel locations to Monaco Ranges.\n    **/\n   [HIGHLIGHT_TYPE.ELEMENT]: (\n      path,\n      jsxTypeOptions,\n      highlighterOptions,\n   ) => {\n      const [\n         openingElement, elementName, startLoc, endLoc\n      ] = extractJSXOpeningElement(path);\n      \n      const result = [];\n      \n      if (openingElement) {\n         result.push([\n            startLoc,\n            highlighterOptions.isUseSeparateElementStyles ?\n               JSXTypes.JSXBracket.openingElementOptions\n               : JSXTypes.JSXBracket.options\n         ]);\n         \n         result.push([\n            endLoc,\n            highlighterOptions.isUseSeparateElementStyles ?\n               JSXTypes.JSXBracket.openingElementOptions\n               : JSXTypes.JSXBracket.options\n         ]);\n      }\n      \n      const [\n         closingElement, , closingElementStartLoc, closingElementEndLoc\n      ] = extractJSXClosingElement(path);\n      \n      if (closingElement) {\n         result.push([\n            closingElementStartLoc,\n            highlighterOptions.isUseSeparateElementStyles ?\n               JSXTypes.JSXBracket.closingElementOptions\n               : JSXTypes.JSXBracket.options\n         ]);\n         result.push([\n            closingElementEndLoc,\n            highlighterOptions.isUseSeparateElementStyles ?\n               JSXTypes.JSXBracket.closingElementOptions\n               : JSXTypes.JSXBracket.options\n         ]);\n      }\n      \n      const loc = getLoc(path);\n      highlighterOptions.isHighlightGlyph && result.push([\n         loc,\n         JSXTypes.JSXElement.options(elementName)\n      ]);\n      return result;\n   },\n   [HIGHLIGHT_TYPE.ALL]: (\n      path,\n      jsxTypeOptions,\n      highlighterOptions,\n   ) => {\n      const curatedLoc = getCuratedLoc(path);\n      const result = [];\n      curatedLoc && result.push([\n         curatedLoc,\n         prepareOptions(path, jsxTypeOptions, highlighterOptions)\n      ]);\n      return result;\n   },\n   [HIGHLIGHT_TYPE.IDENTIFIER]: (\n      path,\n      jsxTypeOptions,\n      highlighterOptions,\n   ) => {\n      if (!isJSXIdentifier(path)) {\n         return [];\n      }\n      \n      return HIGHLIGHT_MODE[HIGHLIGHT_TYPE.ALL](\n         path,\n         isParentJSXAttribute(path) ?\n            JSXTypes.JSXAttribute.options : jsxTypeOptions,\n         highlighterOptions,\n      );\n   },\n   [HIGHLIGHT_TYPE.EDGE]: (\n      path,\n      jsxTypeOptions,\n      highlighterOptions,\n   ) => {\n      const options = prepareOptions(path, jsxTypeOptions, highlighterOptions);\n      \n      const [\n         , , startEdgeLoc, endEdgeLoc\n      ] = extractJSXExpressionEdges(path);\n      \n      const result = [];\n      \n      result.push([\n         startEdgeLoc,\n         options\n      ]);\n      result.push([\n         endEdgeLoc,\n         options\n      ]);\n      \n      return result;\n      \n   },\n   [HIGHLIGHT_TYPE.STYLE]: () => [], // noop\n};\n\nexport const JSXTypes = {\n   JSXIdentifier: {\n      highlightScope: HIGHLIGHT_TYPE.IDENTIFIER,\n      options: {\n         inlineClassName: 'JSXElement.JSXIdentifier',\n      },\n   },\n   JSXOpeningFragment: {\n      highlightScope: HIGHLIGHT_TYPE.ALL,\n      options: {\n         inlineClassName: 'JSXOpeningFragment.JSXBracket',\n      },\n   },\n   JSXClosingFragment: {\n      highlightScope: HIGHLIGHT_TYPE.ALL,\n      options: {\n         inlineClassName: 'JSXClosingFragment.JSXBracket',\n      },\n   },\n   JSXText: {\n      highlightScope: HIGHLIGHT_TYPE.ALL,\n      options: {\n         inlineClassName: 'JSXElement.JSXText',\n      },\n   },\n   JSXExpressionContainer: {\n      highlightScope: HIGHLIGHT_TYPE.EDGE,\n      options: {\n         inlineClassName: 'JSXExpressionContainer.JSXBracket',\n      },\n   },\n   JSXSpreadChild: {\n      highlightScope: HIGHLIGHT_TYPE.EDGE,\n      options: {\n         inlineClassName: 'JSXSpreadChild.JSXBracket',\n      },\n   },\n   JSXSpreadAttribute: {\n      highlightScope: HIGHLIGHT_TYPE.EDGE,\n      options: {\n         inlineClassName: 'JSXSpreadAttribute.JSXBracket',\n      },\n   },\n   JSXElement: {\n      highlightScope: HIGHLIGHT_TYPE.ELEMENT, //HIGHLIGHT_TYPE.STYLE,\n      options: (elementName) => (\n         {\n            glyphMarginClassName: 'JSXElement.JSXGlyph',\n            glyphMarginHoverMessage:\n               `JSX Element${elementName ? ': ' + elementName : ''}`\n         }\n      ),\n   },\n   JSXBracket: {\n      highlightScope: HIGHLIGHT_TYPE.STYLE,\n      options: {\n         inlineClassName: 'JSXElement.JSXBracket',\n      },\n      openingElementOptions: {\n         inlineClassName: 'JSXOpeningElement.JSXBracket',\n      },\n      closingElementOptions: {\n         inlineClassName: 'JSXClosingElement.JSXBracket',\n      },\n   },\n   JSXOpeningElement: {\n      highlightScope: HIGHLIGHT_TYPE.STYLE,\n      options: {\n         inlineClassName: 'JSXOpeningElement.JSXIdentifier',\n      },\n   },\n   JSXClosingElement: {\n      highlightScope: HIGHLIGHT_TYPE.STYLE,\n      options: {\n         inlineClassName: 'JSXClosingElement.JSXIdentifier',\n      },\n   },\n   JSXAttribute: {\n      highlightScope: HIGHLIGHT_TYPE.STYLE,\n      options: {\n         inlineClassName: 'JSXAttribute.JSXIdentifier',\n      },\n   },\n};\n\nclass DecoratorMapper {\n   constructor(monacoEditor, loc2Range, _JSXTypes = JSXTypes) {\n      let decorators = [];\n      let jsxDecoratorIds = [];\n      \n      const addDecorator = ([loc, options]) => {\n         return decorators.push({\n            range: loc2Range(loc),\n            options\n         });\n      }\n      \n      const deltaDecorations = () => {\n         jsxDecoratorIds =\n            monacoEditor.deltaDecorations(\n               jsxDecoratorIds || [],\n               decorators\n            );\n         decorators = [];\n         return jsxDecoratorIds;\n      }\n      \n      this.deltaJSXDecorations = (jsxExpressions, options) => {\n         for (const jsxType in _JSXTypes) {\n            jsxExpressions.filter(path => path.type === jsxType)\n               .forEach(path =>\n                  HIGHLIGHT_MODE[_JSXTypes[jsxType].highlightScope](\n                     path,\n                     _JSXTypes[jsxType].options,\n                     options,\n                  ).forEach(entry => addDecorator(entry))\n               );\n         }\n         \n         return deltaDecorations();\n      }\n      \n      this.reset = () => {\n         decorators = [];\n         deltaDecorations();\n      }\n      \n      this.reset();\n   }\n}\n\nexport default DecoratorMapper;\n","export const JSXCommentContexts = {\n   JS: 'JS',\n   JSX: 'JSX'\n}\n\nexport function getJSXContext(\n   jsxExpressions,\n   commentableRange,\n   commentContainingRange,\n   loc2Range\n) {\n   if (!(jsxExpressions &&\n      commentableRange &&\n      commentContainingRange &&\n      loc2Range)) {\n      return JSXCommentContexts.JS;\n   }\n   \n   \n   let minRange = null;\n   let minCommentableRange = null;\n   let path = null;\n   let commentablePath = null;\n   \n   jsxExpressions.forEach(p => {\n      const jsxRange = loc2Range(p.node.loc);\n      if ((p.key === 'name' || p.key === 'property') &&\n         p.isJSXIdentifier() &&\n         jsxRange.intersectRanges(commentableRange)) {\n         if (\n            !minCommentableRange ||\n            minCommentableRange.containsRange(jsxRange)\n         ) {\n            minCommentableRange = jsxRange;\n            commentablePath = p;\n         }\n      }\n      if (jsxRange.intersectRanges(commentContainingRange)) {\n         if (!minRange || minRange.containsRange(jsxRange)) {\n            minRange = jsxRange;\n            path = p;\n         }\n      }\n   });\n   \n   if (!path || path.isJSXExpressionContainer() || commentablePath) {\n      return JSXCommentContexts.JS;\n   } else {\n      return JSXCommentContexts.JSX;\n   }\n}\n\nclass Commenter {\n   constructor(\n      monacoEditorManager,\n      parseJSXExpressionsPromise\n   ) {\n      \n      let _editorCommandId = null;\n      \n      this.getEditorCommandId = () => {\n         return _editorCommandId;\n      }\n      \n      let _isJSXCommentCommandActive = false;\n      \n      this.isJSXCommentCommandActive = () => {\n         return _isJSXCommentCommandActive;\n      }\n      \n      const editorCommandOnDispose = () => {\n         _isJSXCommentCommandActive = false;\n      };\n      \n      this.runJsxCommentAction = (selection, commentContext) => {\n         const {\n            monacoEditor, monaco, runEditorCommentLineAction,\n            getSelectionFirstLineText,\n         } = monacoEditorManager;\n         \n         const jsCommentText = getSelectionFirstLineText();\n         \n         if (jsCommentText.match(/^\\s*\\/[/*]/)) {\n            runEditorCommentLineAction();\n            return;\n         }\n         \n         const model = monacoEditor.getModel();\n         \n         let isUnCommentAction = true;\n         const commentsData = [];\n         \n         for (\n            let i = selection.startLineNumber; i <= selection.endLineNumber; i++\n         ) {\n            const commentRange = new monaco.Range(\n               i,\n               model.getLineFirstNonWhitespaceColumn(i),\n               i,\n               model.getLineMaxColumn(i),\n            );\n            \n            const commentText = model.getValueInRange(commentRange);\n            \n            commentsData.push({\n               commentRange,\n               commentText\n            });\n            \n            isUnCommentAction = isUnCommentAction &&\n               !!commentText.match(/{\\/\\*/);\n         }\n         \n         if (commentContext !== JSXCommentContexts.JSX\n            && !isUnCommentAction) {\n            runEditorCommentLineAction();\n            return;\n         }\n         \n         let editOperations = [];\n         let commentsDataIndex = 0;\n         \n         for (let i = selection.startLineNumber;\n              i <= selection.endLineNumber;\n              i++) {\n            let {\n               commentText,\n               commentRange,\n            } = commentsData[commentsDataIndex++];\n            \n            if (isUnCommentAction) {\n               commentText = commentText.replace(/{\\/\\*/, '');\n               commentText = commentText.replace(/\\*\\/}/, '');\n            } else {\n               commentText = `{/*${commentText}*/}`;\n            }\n            \n            editOperations.push({\n               identifier: {major: 1, minor: 1},\n               range: commentRange,\n               text: commentText,\n               forceMoveMarkers: true,\n            });\n         }\n         editOperations.length &&\n         monacoEditor.executeEdits(_editorCommandId, editOperations);\n      }\n      \n      this.addJSXCommentCommand = () => {\n         const {\n            monacoEditor, monaco, loc2Range, runEditorCommentLineAction,\n            getCommentableStartingRange, getCommentContainingStartingRange\n         } = monacoEditorManager;\n         \n         if (_editorCommandId) {\n            _isJSXCommentCommandActive = true;\n            return editorCommandOnDispose;\n         }\n         \n         _editorCommandId = monacoEditor.addCommand(\n            monaco.KeyMod.CtrlCmd | monaco.KeyCode.US_SLASH,\n            () => {\n               if (!_isJSXCommentCommandActive) {\n                  runEditorCommentLineAction();\n                  return;\n               }\n               \n               parseJSXExpressionsPromise()\n                  .then(jsxExpressions => {\n                     const selection = monacoEditor.getSelection();\n                     const commentContext = getJSXContext(\n                        jsxExpressions,\n                        getCommentableStartingRange(selection),\n                        getCommentContainingStartingRange(selection),\n                        loc2Range\n                     );\n                     this.runJsxCommentAction(selection, commentContext);\n                  }).catch(()=>{\n                   runEditorCommentLineAction();\n               });\n            });\n         \n         _isJSXCommentCommandActive = true;\n         \n         monacoEditor.onDidDispose(editorCommandOnDispose);\n         \n         return editorCommandOnDispose;\n      }\n   }\n}\n\nexport default Commenter;\n","import {\n   configureLoc2Range,\n   configureRange2Loc,\n   MonacoEditorManager\n} from '../utils/monaco';\nimport {collectJSXExpressions} from '../utils/babel';\nimport DecoratorMapper from './DecoratorMapper';\nimport Commenter from './Commenter';\n\nconst defaultOptions = {\n   parser: 'babel',\n   isHighlightGlyph: false,\n   iShowHover: false,\n   isUseSeparateElementStyles: false,\n   jsxCommenter: null,\n   monacoEditorManager: null,\n   decoratorMapper: null,\n};\n\nexport const makeGetAstPromise = (parse, monacoEditor) => () => {\n   return new Promise(\n      (resolve, reject) => {\n         try {\n            return resolve(\n               parse(monacoEditor.getValue()) // ast\n            );\n         } catch (e) {\n            return reject(e);\n         }\n      }\n   );\n};\n\nexport const makeParseJSXExpressionsPromise = (\n   traverse, getAstPromise, _collectJSXExpressions = collectJSXExpressions\n) => () => {\n   return new Promise((resolve, reject) => {\n      getAstPromise()\n         .then(ast => {\n               try {\n                  return resolve(\n                     _collectJSXExpressions(ast, traverse)\n                  );\n               } catch (e) {\n                  return reject(e);\n               }\n            }\n         ).catch(e => reject(e));\n   });\n};\n\nexport const makeJSXCommenterBundle = (\n   monaco, parse, traverse, monacoEditor, options = {}\n) => {\n   const {parserType, jsxCommenter, monacoEditorManager} = options;\n   const range2Loc = configureRange2Loc(parserType);\n   const loc2Range = configureLoc2Range(monaco, parserType);\n   \n   const getAstPromise = makeGetAstPromise(parse, monacoEditor);\n   \n   const parseJSXExpressionsPromise = makeParseJSXExpressionsPromise(\n      traverse, getAstPromise\n   );\n   \n   const _monacoEditorManager = monacoEditorManager ||\n      new MonacoEditorManager(monacoEditor, monaco, loc2Range);\n   \n   const _jsxCommenter = jsxCommenter || new Commenter(\n      _monacoEditorManager, parseJSXExpressionsPromise\n   );\n   \n   return [\n      _jsxCommenter, _monacoEditorManager,\n      parseJSXExpressionsPromise, getAstPromise,\n      loc2Range, range2Loc\n   ];\n};\n\n// Minimal Babel setup for React JSX parsing:\nexport const makeBabelParse = (parse) => {\n   return (code, options = {}) => {\n      return parse(\n         code,\n         {\n            ...options,\n            sourceType: \"module\",\n            plugins: [\"jsx\"],\n            errorRecovery: true\n         });\n      \n   };\n};\n\nclass MonacoJSXHighlighter {\n   constructor(\n      monaco,\n      parse,\n      traverse,\n      monacoEditor,\n      options = {}\n   ) {\n      this.options = {...defaultOptions, ...options};\n      \n      const {jsxCommenter, monacoEditorManager, decoratorMapper} = this.options;\n      \n      this.babelParse = makeBabelParse(parse);\n      \n      const [\n         _jsxCommenter, _monacoEditorManager,\n         parseJSXExpressionsPromise, getAstPromise,\n         loc2Range, range2Loc\n      ] = makeJSXCommenterBundle(\n         monaco, this.babelParse, traverse, monacoEditor, this.options\n      );\n      \n      this.jsxCommenter = jsxCommenter || _jsxCommenter;\n      this.monacoEditorManager = monacoEditorManager || _monacoEditorManager;\n      this.parseJSXExpressionsPromise = parseJSXExpressionsPromise;\n      this.getAstPromise = getAstPromise;\n      this.loc2Range = loc2Range;\n      this.range2Loc = range2Loc;\n      \n      this.addJSXCommentCommand = this.jsxCommenter.addJSXCommentCommand;\n      \n      \n      this.decoratorMapper = decoratorMapper ||\n         new DecoratorMapper(monacoEditor, this.loc2Range);\n      this.decoratorMapperReset = () => {\n         decoratorMapper.reset()\n      };\n      \n      this.highlight = (\n         ast, _collectJSXExpressions = collectJSXExpressions\n      ) => {\n         return new Promise((resolve, reject) => {\n            const {decoratorMapper, options} = this;\n            const result = {\n               decoratorMapper,\n               options,\n               ast,\n               jsxExpressions: [],\n            };\n            \n            //ignore update if parsing was unsuccessful\n            if (!ast) {\n               return resolve(result);\n            }\n            \n            try {\n               const jsxExpressions = _collectJSXExpressions(ast, traverse);\n               \n               decoratorMapper.deltaJSXDecorations(\n                  jsxExpressions, options\n               );\n               \n               result.jsxExpressions = jsxExpressions;\n               \n               return resolve(result);\n            } catch (e) {\n               return reject(e);\n            }\n         });\n      };\n      \n      this.highlightCode = (\n         afterHighlight = ast => ast,\n         onHighlightError = error => error,\n         getAstPromise = this.getAstPromise,\n         onGetAstError = error => error,\n      ) => {\n         return (\n            getAstPromise()\n               .then(ast => {\n                  this.highlight(ast)\n                     .then(afterHighlight)\n                     .catch(onHighlightError)\n               })\n               .catch(onGetAstError)\n         );\n      };\n      \n      let _isHighlightBoundToModelContentChanges = false;\n      \n      this.isHighlightBoundToModelContentChanges =\n         () => _isHighlightBoundToModelContentChanges;\n      \n      this.highlightOnDidChangeModelContent = (\n         debounceTime = 100,\n         afterHighlight = ast => ast,\n         onHighlightError = error => error,\n         getAstPromise = this.getAstPromise,\n         onParseAstError = error => error,\n      ) => {\n         const highlightCallback = () => {\n            return this.highlightCode(\n               afterHighlight,\n               onHighlightError,\n               getAstPromise,\n               onParseAstError\n            );\n         };\n         \n         highlightCallback();\n         \n         let tid = null;\n         \n         let highlighterDisposer = {\n            onDidChangeModelContentDisposer:\n               monacoEditor.onDidChangeModelContent(\n                  () => {\n                     clearTimeout(tid);\n                     tid = setTimeout(\n                        highlightCallback,\n                        debounceTime\n                     );\n                  }),\n            onDidChangeModelDisposer: monacoEditor.onDidChangeModel(\n               () => {\n                  highlightCallback();\n               })\n         };\n         \n         highlighterDisposer.dispose = () => {\n            highlighterDisposer.onDidChangeModelContentDisposer.dispose();\n            highlighterDisposer.onDidChangeModelDisposer.dispose();\n         };\n         \n         _isHighlightBoundToModelContentChanges = true;\n         \n         const onDispose = () => {\n            this.decoratorMapper.reset();\n            if (\n               !_isHighlightBoundToModelContentChanges\n            ) {\n               return;\n            }\n            _isHighlightBoundToModelContentChanges = false;\n            highlighterDisposer && highlighterDisposer.dispose();\n            highlighterDisposer = null;\n            \n         }\n         \n         monacoEditor.onDidDispose(() => {\n            this.decoratorMapper.reset();\n            highlighterDisposer = null;\n            _isHighlightBoundToModelContentChanges = false;\n         });\n         \n         \n         return onDispose;\n      };\n      \n      // backwards compatible typo preserve to avoid breaking changes\n      this.highLightOnDidChangeModelContent =\n         this.highlightOnDidChangeModelContent;\n   }\n}\n\n// use .polyfilled dist when usign node < 10. // .babelrc.json:  \"node\": \"0\"\nexport default MonacoJSXHighlighter;\n"],"names":["_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","collectJSXExpressions","ast","traverse","traverseOptions","jsxExpressions","enter","path","toUpperCase","includes","push","isJSXIdentifier","isParentJSXAttribute","parentPath","isJSXAttribute","getLoc","node","loc","cloneLoc","start","end","getCuratedLoc","container","property","extractJSXOpeningElement","openingElement","elementName","name","startLoc","endLoc","column","selfClosing","extractJSXClosingElement","closingElement","extractJSXExpressionEdges","innerNode","innerLocKey","isJSXSpreadChild","isJSXSpreadAttribute","innerLoc","extra","parenthesized","COMMENT_ACTION_ID","configureLoc2Range","monaco","startLineOffset","startColumnOffset","endLineOffset","endColumnOffset","Range","line","configureRange2Loc","rangeOrPosition","lineNumber","startLineNumber","startColumn","endLineNumber","endColumn","MonacoEditorManager","constructor","monacoEditor","loc2Range","this","runEditorCommentLineAction","getAction","run","getLineIndentationColumn","getModel","getLineFirstNonWhitespaceColumn","getCommentableStartingRange","range","getCommentContainingStartingRange","getSelectionFirstLineText","model","getSelection","jsCommentRange","getLineMaxColumn","getValueInRange","prepareOptions","jsxTypeOptions","highlighterOptions","iShowHover","hoverMessage","HIGHLIGHT_TYPE","ELEMENT","ALL","IDENTIFIER","EDGE","STYLE","HIGHLIGHT_MODE","result","isUseSeparateElementStyles","JSXTypes","JSXBracket","openingElementOptions","options","closingElementStartLoc","closingElementEndLoc","closingElementOptions","isHighlightGlyph","JSXElement","curatedLoc","JSXAttribute","startEdgeLoc","endEdgeLoc","JSXIdentifier","highlightScope","inlineClassName","JSXOpeningFragment","JSXClosingFragment","JSXText","JSXExpressionContainer","JSXSpreadChild","JSXSpreadAttribute","glyphMarginClassName","glyphMarginHoverMessage","JSXOpeningElement","JSXClosingElement","DecoratorMapper","_JSXTypes","decorators","jsxDecoratorIds","addDecorator","deltaDecorations","deltaJSXDecorations","jsxType","filter","forEach","entry","reset","JSXCommentContexts","JS","JSX","getJSXContext","commentableRange","commentContainingRange","minRange","minCommentableRange","commentablePath","p","jsxRange","intersectRanges","containsRange","isJSXExpressionContainer","Commenter","monacoEditorManager","parseJSXExpressionsPromise","_editorCommandId","getEditorCommandId","_isJSXCommentCommandActive","isJSXCommentCommandActive","editorCommandOnDispose","runJsxCommentAction","selection","commentContext","match","isUnCommentAction","commentsData","commentRange","commentText","editOperations","commentsDataIndex","replace","identifier","major","minor","text","forceMoveMarkers","executeEdits","addJSXCommentCommand","addCommand","KeyMod","CtrlCmd","KeyCode","US_SLASH","then","catch","onDidDispose","defaultOptions","parser","jsxCommenter","decoratorMapper","makeGetAstPromise","parse","Promise","resolve","reject","getValue","e","makeParseJSXExpressionsPromise","getAstPromise","_collectJSXExpressions","makeJSXCommenterBundle","parserType","range2Loc","_monacoEditorManager","_jsxCommenter","makeBabelParse","code","sourceType","plugins","errorRecovery","MonacoJSXHighlighter","babelParse","decoratorMapperReset","highlight","highlightCode","afterHighlight","onHighlightError","error","onGetAstError","_isHighlightBoundToModelContentChanges","isHighlightBoundToModelContentChanges","highlightOnDidChangeModelContent","debounceTime","onParseAstError","highlightCallback","tid","highlighterDisposer","onDidChangeModelContentDisposer","onDidChangeModelContent","clearTimeout","setTimeout","onDidChangeModelDisposer","onDidChangeModel","dispose","onDispose","highLightOnDidChangeModelContent"],"sourceRoot":""}